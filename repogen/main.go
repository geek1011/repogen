package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	//"sort"
	//"strings"
	"time"

	"github.com/geek1011/repogen"
	//"github.com/mattn/go-zglob"
	"github.com/spf13/pflag"
)

var version = "unknown"

func main() {
	maintainerOverride := pflag.StringP("maintainer-override", "m", "", "overrides the maintainer of all packages (format: First Last <email@address.com>)")
	origin := pflag.StringP("origin", "o", "repogen", "sets the origin field used in the Release file (this field is used as a user-friendly way to identify the repository)")
	description := pflag.StringP("description", "d", "Generated by repogen (version: "+version+")", "sets the description field used in the Release file")
	generateContents := pflag.BoolP("generate-contents", "c", false, "generates the Contents index (makes repogen slower to load)")
	generateWeb := pflag.BoolP("generate-web", "b", false, "generate a web interface for browsing the packages")
	watch := pflag.BoolP("watch", "w", false, "watch the input directory for new packages")
	watchInterval := pflag.DurationP("watch-interval", "i", time.Second, "the interval to check for new packages (if watch is enabled)")
	help := pflag.BoolP("help", "h", false, "show this help text")
	sversion := pflag.Bool("version", false, "show the version")
	pflag.Parse()

	if *sversion {
		fmt.Printf("repogen %s\n", version)
		os.Exit(0)
	}

	if *help || pflag.NArg() != 3 {
		fmt.Fprintf(os.Stderr, "Usage: repogen [OPTIONS] PRIVATE_KEY_FILE INPUT_DIR OUTPUT_DIR\n\nVersion:\n  repogen %s\n\nOptions:\n", version)
		pflag.PrintDefaults()
		fmt.Fprintf(os.Stderr, "\nArguments:\n  PRIVATE_KEY_FILE is the path to a ascii-armoured gpg private key with no passphrase. It is used to sign the repository.\n  INPUT_DIR is the path to the directory containing the deb packages. It should be in the following layout (and must not contain any unrelated files): INPUT_DIR/dist/component/*.deb\n  OUTPUT_DIR is the path to place the generated repository in. It must not exist.\n")
		os.Exit(1)
	}

	pkFile := pflag.Arg(0)
	inRoot := pflag.Arg(1)
	outRoot := pflag.Arg(2)

	buf, err := ioutil.ReadFile(pkFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: could not read private key from '%s': %v\n", pkFile, err)
		os.Exit(1)
	}

	if fi, err := os.Stat(inRoot); err != nil {
		fmt.Fprintf(os.Stderr, "Error: error reading input directory '%s': %v\n", inRoot, err)
		os.Exit(1)
	} else if !fi.IsDir() {
		fmt.Fprintf(os.Stderr, "Error: input directory '%s' must be a directory\n", inRoot)
		os.Exit(1)
	}

	if _, err := os.Stat(outRoot); err == nil {
		fmt.Fprintf(os.Stderr, "Error: output directory '%s' must not exist\n", outRoot)
		os.Exit(1)
	}

	if inRoot, err = filepath.Abs(inRoot); err != nil {
		fmt.Fprintf(os.Stderr, "Error: could not resolve path to input directory '%s': %v\n", inRoot, err)
		os.Exit(1)
	}

	if outRoot, err = filepath.Abs(outRoot); err != nil {
		fmt.Fprintf(os.Stderr, "Error: could not resolve path to output directory '%s': %v\n", outRoot, err)
		os.Exit(1)
	}

	r, err := repogen.NewRepo(inRoot, outRoot, *generateContents, *maintainerOverride, *origin, *description, string(buf))
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: could not set up repo'%s': %v\n", *origin, err)
		os.Exit(1)
	}
	if err = r.ServeRepo(*watch, *generateWeb, buf, inRoot, outRoot, int(*watchInterval)); err != nil {
		fmt.Fprintf(os.Stderr, "Error: could not serve up repo'%s': %v\n", *origin, err)
		os.Exit(1)
	} else {
		os.Exit(0)
	}
}
